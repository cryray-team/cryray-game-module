#include "common.h"

#include "lmodel.h"
#include "hmodel.h"

uniform	Texture2D					s_half_depth;

#ifdef SSFX_SSR
	#include "screenspace_addon\screenspace_reflections.h"
#endif

#include "screenspace_addon\screenspace_fog.h"

Texture2D<float> s_occ;

struct	_input
{
	float4	tc0	: TEXCOORD0;	// tc.xy, tc.w = tonemap scale
	float2	tcJ	: TEXCOORD1;	// jitter coords
	float4 pos2d : SV_Position;
};

struct	_out
{
	float4	low		: SV_Target0;
	float4	high	: SV_Target1;
};

//	TODO:	DX10: Replace Sample with Load
_out main ( _input I ) : SV_Target
{
	gbuffer_data gbd = gbuffer_load_data( GLD_P(I.tc0, I.pos2d, ISAMPLE) );
	
	// Sample the buffers:
	float4	P = float4( gbd.P, gbd.mtl );	// position.(mtl or sun)
	float4	N = float4( gbd.N, gbd.hemi );		// normal.hemi
	float4	D = float4( gbd.C, gbd.gloss );		// rgb.gloss
	float4	L = s_accumulator.Sample( smp_nofilter, I.tc0);	// diffuse.specular

#ifdef USE_SUPER_SPECULAR
	{
		float ds = dot( D.rgb, 1.h/3.h );
		D.w = max( D.w, ds*ds/8.h );
	}
#endif

#ifdef FORCE_GLOSS
	D.w = FORCE_GLOSS;
#endif

#ifdef USE_GAMMA_22
	D.rgb = ( D.rgb*D.rgb ); // pow(2.2)
#endif

#ifndef SSFX_NEWGLOSS
	if (abs(P.w - MAT_FLORA) <= 0.05) {
		// Reapply distance factor to fix overtly glossy plants in distance
		// Unfortunately some trees etc don't seem to use the same detail shader
		float	fAtten = 1 - smoothstep(0, 50, P.z);
		D.a	*= (fAtten * fAtten);
	}
#endif
        // static sun
	float mtl = P.w;

#ifdef USE_R2_STATIC_SUN
	float sun_occ = P.w*2;

	mtl = xmaterial;
	L += Ldynamic_color * sun_occ * plight_infinity	(mtl, P.xyz, N.xyz, Ldynamic_dir);
#endif

	// hemisphere
	float3 hdiffuse, hspecular;

	//  Calculate SSAO
#ifdef USE_HDAO
	float occ = s_occ.Sample( smp_nofilter, I.tc0);	
#else	
	float3 occ = s_ambient_occlusion.Sample(smp_nofilter, I.tc0.xy);
#endif
	hmodel	(hdiffuse, hspecular, mtl, N.w, D.w, P.xyz, N.xyz);
	hdiffuse *= occ;
	hspecular *= occ;
	
	// Disable specular if SSR is enabled. ( Temporary fix? )
//#ifdef SSFX_SSR
	//hspecular = 0;
//#endif

        float4         light       = float4         (L.rgb + hdiffuse, L.w)        ;
        float4         C           = D*light       ;                             // rgb.gloss * light(diffuse.specular)
	float3         spec        = C.www         + hspecular;      // replicated specular

#ifdef         USE_SUPER_SPECULAR
                      spec      = (C.rgb*.5h + .5h)*C.w + hspecular        ;
#endif
		float3       color     = C.rgb + spec     ;

	// SSR Implementation
#ifdef SSFX_SSR
	SSFX_ScreenSpaceReflections(I.tc0, P, N, D.a, color, ISAMPLE);	
#endif

////////////////////////////////////////////////////////////////////////////////
/// For Test ///////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#ifdef         DBG_TEST_NMAP
//. hemi + sun + lighting + specular
					color 	= 	hdiffuse + L.rgb + N;
#endif

#ifdef         DBG_TEST_NMAP_SPEC
//. hemi + sun + lighting + specular
					color 	= 	hdiffuse + L.rgb + N + spec;
#endif

#ifdef         DBG_TEST_LIGHT
//. hemi + sun + lighting + specular
					color 	= 	hdiffuse + L.rgb;
#endif

#ifdef         DBG_TEST_LIGHT_SPEC
//. hemi + sun + lighting + specular
					color 	= 	hdiffuse + L.rgb + spec;
#endif

#ifdef         DBG_TEST_SPEC
//. only lighting and specular
					color 		= spec;
#endif
////////////////////////////////////////////////////////////////////////////////

        // here should be distance fog
        float3        	pos        		= P.xyz;
        float         	distance		= length		(pos);
		float3 			WorldP			= mul			(m_inv_V, float4(P.xyz, 1));
        float         	fog				= saturate		(distance*fog_params.w + fog_params.x); //

                      	color			= lerp     		(color,fog_color,fog);        			//
        float        	skyblend		= saturate		(fog*fog);

#ifdef         DBG_TMAPPING
        color                        	= D.xyz;
#endif
        float          	tm_scale        = I.tc0.w;                // interpolated from VS

#ifdef        USE_SUPER_SPECULAR
        color        	= spec          - hspecular	;
#endif
//		color 		= N; //show normals
//		color                        	= D.xyz;
//		color 

//float3 color = (0.5 * (sign( gbd.N - gbd.N_org ) + 1.0 ) );
//color = float3( abs( gbd.hemi - gbd.hemi_org), 0, abs( gbd.mtl - gbd.mtl_org) );
//color = abs( gbd.N - gbd.N_org );
//		color = occ; // holger test
		//color = gbd.N;
		
		//color = occ;
		
        _out        	o;
        tonemap        	(o.low, o.high, color, tm_scale )	;
                        o.low.a         = skyblend	;
						o.high.a		= skyblend	;
//		o.low	= skyblend;
//		o.hight	= 0;

	//o.low = float4(gbd.P,1);

	//o.low = float4( 1.0f, 0.0f, 0.0f, 1.0f );

		return        	o;
}
